# shellcheck shell=bash
#
# FILE: _quick_change_dir
#
# ABSTRACT: Quick Change Directory
#
#
# The base idea of quick change directory ("qc") is to create a index
# containing all directories in your HOME directory and to use the command 'qc'
# to quick change to a directory by searching for a matching name in that
# index. The index file is simple text file containing one directory per line.
#
# See README.md for a full description.
#
# AUTHOR: Ralf Schandl
#

# Directory for qc index files
[ -z "$QC_DIR" ] && QC_DIR=$HOME/.qc

# Manual index file storing directory names and bookmarked directories. This
# file is managed using the command 'dstore'.
QC_DSTORE_INDEX=$QC_DIR/index.dstore

#function qc_debug
#{
#    echo "$*" >> $HOME/qc-debug.log
#    echo >&2 "$@"
#}

# Create regex from qc argument
# Used from qc and completion
# $*: The pattern to create a regex
function __qc_args2regex
{
    typeset glob regex w

    for w in "$@"; do
        # w="${w//+/*}"
        case "$w" in
            */) # don't append '*' if word ends with '/'
                w="${w%?}";;
            *\*) # don't append '*' if it already ends with '*'
                : ;;
            *)   w="$w*" ;;
        esac
        glob="$glob/$w"
    done

    # Remove
    # - leading slashes
    # - than leading asterixes followed by slashes
    # - than trailing slashes
    glob="$(echo "$glob" | sed 's%^//*%%;s%^\*\**//*%%;s%//*$%%')"

    while [ -n "$glob" ]; do

        case "$glob" in
            \*\*/*) # '**' -> '.*'
                regex="$regex\(.*/\)*"
                glob="${glob:3}"
                ;;
            \*\**) # '**' -> '.*'
                regex="$regex.*"
                # shellcheck disable=SC2001
                glob="$(echo "$glob" | sed "s/^\\*\\**//")"
                ;;
            //*) # '//' -> '/.*/'
                regex="$regex/\\(.*/\\)*"
                # shellcheck disable=SC2001
                glob="$(echo "$glob" | sed "s%^///*%%")"
                ;;
            \**) # '*' -> '[^/]*'
                regex="${regex}[^/]*"
                glob="${glob:1}"
                ;;
            \?*) # '?' -> '[^/]'
                regex="${regex}[^/]"
                glob="${glob:1}"
                ;;
            \\\?*) # copy escaped char
                regex="${regex}?"
                glob="${glob:2}"
                ;;
            \\*) # copy escaped char
                regex="$regex${glob:0:2}"
                glob="${glob:2}"
                ;;
            .*)
                regex="$regex\\."
                glob="${glob:1}"
                ;;
            *)
                regex="$regex${glob:0:1}"
                glob="${glob:1}"
                ;;
        esac
    done
    #remove leading '/'
    #regex="${regex:1}$"
    regex="${regex}$"
    echo "$regex"
}

# Select directories found in ~/.qc/*.index.
# $1: grep options (ignored for search by label)
# $2: Search extended indexes? ("true" or "")
# $3-: text to search for. With leading ':' triggers search by label.
function __qc_select
{
    typeset grepOpt="$1"
    shift
    typeset searchExtIdx="$1"
    shift

    if [ "$searchExtIdx" ]; then
        if ls "$QC_DIR"/*.index.ext >/dev/null 2>&1; then
            extIdx="$QC_DIR/*.index.ext"
        fi
    fi

    typeset IFS=$'\n'
    typeset NO_IDX_MSG="qc: No index file found! Use 'qc -u' or 'dstore' to create it."
    typeset NO_DSTORE_IDX_MSG="qc: Dstore index file not found! Use 'dstore' to create it."
    typeset dl
    case $1 in
        :*)
            pattern=$1
            [ $# -gt 1 ] && echo >&2 "WARNING: Extra arguments ignored"
            # grep: -h: Suppress the prefixing of file names on output.
            # shellcheck disable=SC2207
            dl=( $( (grep -ahi -- "^${pattern}[^ ]* " "$QC_DSTORE_INDEX" ||([ $? = 2 ] && echo >&2 "$NO_DSTORE_IDX_MSG")) | cut "-d " -f2- | sort | uniq) )
            ;;
        *)
            pattern=$(__qc_args2regex "$@")
            # shellcheck disable=SC2086,2207
            dl=( $( (grep --color=always -ah $grepOpt -- "/$pattern" "$QC_DIR"/*.index "$QC_DSTORE_INDEX" $extIdx || ([ $? = 2 ] && echo >&2 "$NO_IDX_MSG"))|sed "s/^:[^ ]* //"|sort|uniq) )
            ;;
    esac

    typeset cnt=${#dl[*]}

    if [ "$cnt" -eq 0 ]; then
        typeset IFS=' '
        echo >&2 "qc: $*: No matching directory found"
        return 1
    elif [ "$cnt" -eq 1 ]; then
        # echo and remove color codes
        echo "${dl[@]}" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
        return 0
    else
        # If selection list needs more than terminal hight lines
        # ask user, if he/she really want's to see it.
        typeset limit=$((LINES -1))
        if [ "$cnt" -gt $limit ]; then

            echo >&2 -n "Display all $cnt directories? (y or n) "
            read -rN1 yn
            # ZSH: read -k yn
            case $yn in
                y|Y) echo >&2
                    ;;
                *) echo >&2
                    return;;
            esac
        fi

        # filter out none existing dirs
        typeset i
        typeset orgCnt=$cnt
        # ZSH: Arrays start with 1
        for (( i=0; i<=orgCnt; i++ )); do
            echo >&2 -en "\rFiltering none existing directories: $i/$orgCnt"
            # remove color codes for check
            [ ! -d "$(echo "${dl[$i]}"| sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g")" ] && unset "dl[$i]"
        done
        dl=( "${dl[@]}" )
        echo >&2 -en "\r\e[K"

        cnt=${#dl[*]}
        if [ "$orgCnt" -ne "$cnt" ]; then
            echo >&2 "qc: Removed $((orgCnt - cnt)) non existing directories from result"
        fi
        if [ "$cnt" -eq 0 ]; then
            echo >&2 "qc: $*: No matching directory found"
            return
        elif [ "$cnt" -eq 1 ]; then
            # echo and remove color codes
            echo "${dl[@]}" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
            return
        fi

        typeset COLUMNS=0
        # replace home directory with '~' for display and later re-add it on
        # choosen dir.
        dl=( "${dl[@]/#$HOME/\~}" )
        # ZSH: dl=( "${dl[@]/#$HOME/~}" )
        # ZSH: On ZSH the following select only display subset (term-height lines)
        export LINES=0
        select dir in "${dl[@]}" ; do
            # replace ~ with $HOME and remove color codes
            echo "${dir/#\~/$HOME}" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
            break
        done
    fi
}

# Quick change directory
function qc
{
    # The command used for changing directories
    if [ "$BASH_VERSION" ]; then
        typeset CD_CMD="builtin cd"
    else
        typeset CD_CMD="cd"
    fi

    # no argument - cd to home
    if [ $# -eq 0 ]; then
        $CD_CMD
        return $?
    elif [ "$1" = "-" ]; then
        $CD_CMD -
        return $?
    fi

    typeset grepOpt=""
    typeset searchExtIdx=""
    typeset OPTIND
    typeset o

    while getopts ":ieuUSl" o "$@"; do
        case $o in
            i) grepOpt="-i"
                ;;
            e) searchExtIdx="true"
                ;;
            u)
                # ZSH: Only shift by OPTIND?
                shift $((OPTIND-1))
                __qc_updateIndex -E "$@"
                return 0
                ;;
            U)
                # ZSH: Only shift by OPTIND?
                shift $((OPTIND-1))
                __qc_updateIndex "$@"
                return 0
                ;;
            S)
                typeset fn
                for fn in "$QC_DIR"/*.index "$QC_DIR"/*.index.ext; do
                    if [ -e "$fn" ]; then
                        echo "$fn"
                        echo "   Last Upd: $(stat -c "%y" "$fn")"
                        # shellcheck disable=SC2183,SC2046,SC2002
                        printf "   Entries:  %'d (%'d bytes)\n" $(cat "$fn" | wc -lc)
                    fi
                done
                if [ -e "$QC_DSTORE_INDEX" ]; then
                    echo "$QC_DSTORE_INDEX"
                    echo "   Last Upd: $(stat -c "%y" "$QC_DSTORE_INDEX")"
                    # shellcheck disable=SC2183,SC2046,SC2002
                    printf "   Entries:  %'d (%'d bytes)\n" $(cat "$QC_DSTORE_INDEX" | wc -lc)
                    echo "   Labeled entries:  $(grep -c "^:" "$QC_DSTORE_INDEX")"
                fi
                return 0
                ;;
            l)
                grep '^:[^ ]* ' "$QC_DSTORE_INDEX"
                return 0
                ;;
            *)
                if [[ "$*" != *--help* ]]; then
                    echo >&2 "Invalid option '$OPTARG'" && echo >&2 ""
                fi
                echo >&2 "Quick Change -- index based directory changer"
                echo >&2 ""
                echo >&2 "Usage:"
                echo >&2 "  qc [-ie] <dir>"
                echo >&2 "      Search for dir in index and cd to it."
                echo >&2 "      -i  Search case-insensitive (slower)."
                echo >&2 "      -e  Also search extended index."
                echo >&2 "  qc :name"
                echo >&2 "      Search for dir labeled with ':name' in index and cd to it."
                echo >&2 "      Use the command 'dstore' to manage labeled directories."
                echo >&2 "  qc -u [dir...]"
                echo >&2 "      Updates index. If dirs are given only that directories are updated,"
                echo >&2 "      This uses the external command '~/.qc/qc-build-index.sh', if it"
                echo >&2 "      is available. Else the internal update is used."
                echo >&2 "  qc -U [dir...]"
                echo >&2 "      Like '-u', but also updates extended indexes."
                echo >&2 "  qc -l"
                echo >&2 "      List labeled dirs."
                echo >&2 "  qc -S"
                echo >&2 "      Print statistics of index."
                echo >&2 "  qc -"
                echo >&2 "      Act like 'cd -'."
                echo >&2 ""
                echo >&2 "Note: qc automatically adds wildcards"
                echo >&2 "  'qc Documents/Adm' searches for '**/Documents/Adm*'"
                echo >&2 "  'qc Doc Adm' searches for '**/Doc*/Adm*'"
                echo >&2 ""
                echo >&2 "See also: dstore --help"
                echo >&2 ""
                return 1
                ;;
        esac
    done

    # ZSH: Only shift by OPTIND?
    shift $((OPTIND-1))

    #qc_debug "ignorecase:   $ignorecase"
    #qc_debug "Args:         " $(printf '"%s" ' "$@")

    case $1 in
        ?*)
            typeset tgt=$(__qc_select "$grepOpt" "$searchExtIdx" "$@")
            if [ -n "$tgt" ]; then
                $CD_CMD "$tgt"
            else
                return 1
            fi
            ;;
    esac

}

# Update/create the index.
function __qc_updateIndex
{
    if [ -e "$QC_DIR"/qc-build-index.sh ]; then
        echo "Updating index ..."
        typeset -a ARGS
        typeset d
        for d in "$@"; do
            if [ "$d" = "-E" ]; then
                ARGS+=( "-E" )
            else
                d="$(readlink -f "$d")"
                ARGS+=( "-i" "$d")
            fi
        done
        "$QC_DIR"/qc-build-index.sh "${ARGS[@]}"
    else
        echo "Updating index (internal update)..."
        __qc_internalUpdateIndex "$@"
    fi
}

function __qc_internalUpdateIndex
{
    [ ! "$QC_DIR" ] && QC_DIR="$HOME/.qc"
    if [ ! -d "$QC_DIR" ]; then
        mkdir "$QC_DIR" || return 1
    fi

    typeset INDEX_FILE=$QC_DIR/home.index
    typeset NEW_INDEX=$(mktemp "${INDEX_FILE}.XXXX")

    find "${HOME}" -xdev -type d \( -name '.*' -o -name CVS \) -prune -o -xtype d -print >> "$NEW_INDEX"

    mv -f "$NEW_INDEX" "$INDEX_FILE"

    echo "Stored $(wc -l < "$INDEX_FILE") directory names."
}

if [ ! "$__QC_TEST__" ]; then
    if ! ls "$QC_DIR"/*.index >/dev/null 2>&1; then
        echo "QuickChangeDirectory: No index files found .. creating ..."
        __qc_updateIndex
    fi
    if [ ! -e "$QC_DSTORE_INDEX" ]; then
        touch "$QC_DSTORE_INDEX"
    fi
fi



# cleanup ~/.qc/index.dstore
function __dstore_clean
{
    # if action is 'warn' just warn about none-existing dirs
    typeset action=$1
    # delete duplicates
    LC_ALL=C sort "$QC_DSTORE_INDEX" | uniq > "$QC_DSTORE_INDEX.tmp"
    mv -f "$QC_DSTORE_INDEX.tmp" "$QC_DSTORE_INDEX"

    # get other index files
    typeset -a otherIdx
    otherIdx=( "$QC_DIR"/*.index )
    if [ ${#otherIdx[@]} -eq 0 ]; then
        otherIdx=( /dev/null )
    elif [ ${#otherIdx[@]} -eq 1 ]; then
        [ ! -e "${otherIdx[0]}" ] && otherIdx=( /dev/null )
    fi

    typeset IFS=$'\n'
    typeset labels=""
    typeset d
    true > "$QC_DSTORE_INDEX.tmp"
    while read -r d; do
        case $d in
            :*)
                # remove non-existing dirs and warn on duplicate labels
                lbl=$(echo "$d" | cut "-d " -f1)
                dir=$(echo "$d" | cut "-d " -f2-)

                if [ -d "$dir" ]; then
                    echo "$d" >> "$QC_DSTORE_INDEX.tmp"
                    if echo "$labels" | grep -ai  " $lbl " >/dev/null 2>&1; then
                        echo >&2 "Warning: Duplicate label: '$lbl'"
                    fi
                    labels="$labels $lbl "
                else
                    if [ "$action" = "warn" ]; then
                        echo "$d" >> "$QC_DSTORE_INDEX.tmp"
                        echo >&2 "WARNING $d: Does not exist (anymore). Use 'dstore -c' to clean up."
                    else
                        echo >&2 "Removed $d: Does not exist (anymore)."
                    fi
                fi
                ;;
            ?*)
                # ignore dirs already in another index file
                if grep -a "^${d}$" "${otherIdx[@]}" >/dev/null 2>&1; then
                    echo >&2 "Removed $d: Already in $(grep -al "^${d}$" "${otherIdx[@]}")"
                    continue
                fi
                # remove non-existing dirs
                if [ -d "$d" ]; then
                    echo "$d" >> "$QC_DSTORE_INDEX.tmp"
                else
                    if [ "$action" = "warn" ]; then
                        echo "$d" >> "$QC_DSTORE_INDEX.tmp"
                        echo >&2 "WARNING $d: Does not exist (anymore). Use 'dstore -c' to clean up."
                    else
                        echo >&2 "Removed $d: Does not exist (anymore)."
                    fi
                fi
                ;;
        esac
    done < "$QC_DSTORE_INDEX"
    mv -f "$QC_DSTORE_INDEX.tmp" "$QC_DSTORE_INDEX"
}

function __qc_fqname
{
    if [ -d "$1" ]; then
        if ! (cd -- "$1" && pwd); then
            return 1
        fi
    else
        (cd "$(dirname -- "$1")" && echo -n "$(pwd)" && echo "/$(basename -- "$1")")
    fi
}

#
# Command to manage the manual dir index
#
function dstore
{
    # create ~/.qc/index.dstore if it does not exist.
    [ ! -d "$QC_DIR" ] && mkdir "$QC_DIR"
    [ ! -e "$QC_DSTORE_INDEX" ] && touch "$QC_DSTORE_INDEX"

    typeset delete
    typeset OPTIND o

    while getopts ":elcd" o "$@"; do
        case $o in
            e)
                ${VISUAL:-${EDITOR:-vi}} "$QC_DSTORE_INDEX"
                __dstore_clean warn
                return
                ;;
            l)
                cat "$QC_DSTORE_INDEX"
                return
                ;;
            c) __dstore_clean
                return
                ;;
            d) delete=true
                ;;
            *)
                if [[ "$*" != *--help* ]]; then
                    echo >&2 "Invalid option '$OPTARG'" && echo >&2 ""
                fi
                echo >&2 "Manually manage content of $QC_DSTORE_INDEX for usage with 'qc'."
                echo >&2 ""
                echo >&2 "Usage:"
                echo >&2 "  dstore"
                echo >&2 "      store current directory"
                echo >&2 "  dstore dirname"
                echo >&2 "      store given directory"
                echo >&2 "  dstore -d"
                echo >&2 "      remove current directory from index"
                echo >&2 "  dstore -d dirname"
                echo >&2 "      remove given directory from index"
                echo >&2 "  dstore :lbl"
                echo >&2 "      store current directory with label ':lbl'"
                echo >&2 "  dstore :lbl dirname"
                echo >&2 "      store given directory with label ':lbl'"
                echo >&2 "  dstore -d :lbl"
                echo >&2 "      remove directory labeled with ':lbl' from index"
                echo >&2 "  dstore [-e | -l | -c]"
                echo >&2 "      '-e'  edit directory index (using ${VISUAL:-${EDITOR:-vi}})"
                echo >&2 "      '-l'  list directory index"
                echo >&2 "      '-c'  clean up duplicate/none-existing entries"
                echo >&2 ""
                echo >&2 "See also: qc --help"
                echo >&2 ""
                return
                ;;
        esac
    done

    shift $((OPTIND-1))

    if [ $# -eq 0 ]; then
        set -- '.'
    fi

    /bin/cp -f "$QC_DSTORE_INDEX" "$QC_DSTORE_INDEX.org"
    while [ $# -gt 0 ]; do
        case $1 in
            :*)
                typeset lbl=$1
                shift
                if ! echo "$lbl" | grep "^[^[:space:]]*$" >/dev/null 2>&1; then
                    echo >&2 "Invalid label '$lbl'. Must not contain whitespaces."
                    return 1
                fi
                if [ "$delete" = "true" ]; then
                    grep -avi "^$lbl " "$QC_DSTORE_INDEX" > "$QC_DSTORE_INDEX.tmp"
                    mv "$QC_DSTORE_INDEX.tmp" "$QC_DSTORE_INDEX"
                else
                    typeset dir
                    if [ $# -lt 1 ]; then
                        dir=$(__qc_fqname ".")
                    else
                        dir=$(__qc_fqname "$1")
                        shift
                    fi
                    if [ -d "$dir" ]; then
                        grep -avi "^$lbl " "$QC_DSTORE_INDEX" > "$QC_DSTORE_INDEX.tmp"
                        mv "$QC_DSTORE_INDEX.tmp" "$QC_DSTORE_INDEX"
                        echo "$lbl $dir" >> "$QC_DSTORE_INDEX"
                    else
                        echo >&2 "Error: Not a directory: $dir"
                    fi
                fi
                ;;
            ?*)
                dir=$(__qc_fqname "$1")
                shift
                if [ "$delete" = "true" ]; then
                    grep -av "^${dir}$" "$QC_DSTORE_INDEX" > "$QC_DSTORE_INDEX.tmp"
                    mv "$QC_DSTORE_INDEX.tmp" "$QC_DSTORE_INDEX"
                else
                    if [ -d "$dir" ]; then
                        echo "$dir" >> "$QC_DSTORE_INDEX"
                    else
                        echo >&2 "Error: Not a directory: $dir"
                    fi
                fi
                ;;
        esac
    done
    diff "$QC_DSTORE_INDEX.org" "$QC_DSTORE_INDEX" | grep -a -- "^[<>]" | sed "s/^</Removed:/;s/^>/Added:  /"
    rm "$QC_DSTORE_INDEX.org"
    __dstore_clean warn
}

if [ -z "$BASH_VERSION" ]; then
    return
fi
#
# The following is bash-only
#

# qc completion function
function __qc_complete
{
    #qc_debug "_qc_complet ============================"
    typeset cur prev opts
    COMPREPLY=()
    if [ "${BASH_VERSION:0:1}" -ge 4 ]; then
        _get_comp_words_by_ref -n : cur
    else
        # shellcheck disable=SC2001,SC2086
        cur=$(echo ${COMP_LINE:0:$COMP_POINT}|sed "s/^.* //")
    fi
    prev="${COMP_WORDS[*]}"
    #qc_debug "cur >>$cur<<"
    #qc_debug "prev >>$prev<<"
    #qc_debug "CL >>$COMP_LINE<<"

    if echo "$prev" | grep " -[^ ]*u" >/dev/null 2>&1 ; then
        # shellcheck disable=SC2207
        COMPREPLY=( $( compgen -o dirnames -- "$cur") )
        return 0
    fi
    if echo "$prev" | grep " -[^ ]*S" >/dev/null 2>&1 ; then
        return 0
    fi
    if echo "$prev" | grep " -[^ ]*l" >/dev/null 2>&1 ; then
        return 0
    fi

    typeset ic
    typeset sedIC
    if echo "$prev" | grep " -[^ ]*i" >/dev/null 2>&1 ; then
        ic='-i'
        sedIC="i"
    fi
    typeset extIdx
    if echo "$prev" | grep " -[^ ]*e" >/dev/null 2>&1 ; then
        if ls "$QC_DIR"/*.index.ext >/dev/null 2>&1; then
            extIdx="$QC_DIR/*.index.ext"
        fi
    fi
    #qc_debug "CW >>${COMP_WORDS[@]}<<"

    typeset -a parts=( "${COMP_WORDS[@]}" )
    unset parts["0"]
    parts=( "${parts[@]}" )
    #qc_debug "XX ${parts[0]}"
    while [[ ${parts[0]} = -* ]]; do
        #qc_debug "unsetting ${parts[0]}"
        unset parts["0"]
        parts=( "${parts[@]}" )
    done
    #qc_debug "parts >>${parts[@]}<<"

    case "$cur" in
        \~ | \~/*)
            _filedir -d;
            return 0;
            ;;
        . | .. | ../* | ./*)
            _filedir -d;
            return 0;
            ;;
        ':'*)
            #qc_debug "LABEL"
            opts=$(grep -a "^${cur}[^ ]* " "$QC_DSTORE_INDEX" | cut "-d " -f1 | sort | uniq)
            #qc_debug "$opts"
            # shellcheck disable=SC2207
            COMPREPLY=( $(compgen "-S " -W "${opts[*]}" -- "$cur" ))
            typeset i
            for ((i=0; i < ${#COMPREPLY[@]}; i++)); do
                COMPREPLY[$i]=$(printf "%q" "${COMPREPLY[$i]:1}")
                if [ "${BASH_VERSION:0:1}" -lt 4 ]; then
                    COMPREPLY[$i]="${COMPREPLY[$i]} "
                fi
            done
            #qc_debug "COMPREPLY >>${COMPREPLY[*]}<<"
            ;;
        ?*)
            cur=$(eval echo "$cur" 2>/dev/null || eval echo "$cur'" 2>/dev/null || eval echo "$cur\"" 2>/dev/null || "")
            #qc_debug "cur >>$cur<<"
            # shellcheck disable=SC2001
            cur=$(echo "$cur" | sed "s%^/%%")   # remove leading '/'
            # curRE: Regular expression to find dir in index
            typeset curRE=$(__qc_args2regex "${parts[@]}")
            # shellcheck disable=SC2001
            typeset curRE=$(echo "$curRE" | sed "s%\([^*]\)\$$%\1/[^/]*$%")
            # cleanRE: RE to delete unneeded part from result
            # shellcheck disable=SC2001
            typeset cleanRE=$(echo "$curRE" | sed "s%\[^/\]\*.$%%")
            #qc_debug "curRE >>$curRE<<"
            #qc_debug "cleanRE >>$cleanRE<<"
            typeset IFS=$'\n'
            # shellcheck disable=SC2086,SC2207
            opts=($(grep -a --no-filename $ic -o -- "/$curRE" "$QC_DIR"/*.index "$QC_DSTORE_INDEX" $extIdx | sort | uniq  | sed "s|^.*/${cleanRE}|/${cur}|$sedIC" | cut -c2-))
            #qc_debug "OPTS >>${opts[*]}<<"
            # shellcheck disable=SC2207
            COMPREPLY=( $(compgen -o nospace -S/ -W "${opts[*]}" -- "$cur" ))
            #COMPREPLY=( "${opts[@]}")
            if [ "${BASH_VERSION:0:1}" -ge 4 ]; then
                compopt -o nospace
            fi
            #qc_debug "COMPREPLY >>${COMPREPLY[*]}<<"
            for ((i=0; i < ${#COMPREPLY[@]}; i++)); do
                COMPREPLY[$i]=$(printf "%q" "${COMPREPLY[$i]}")
            done
            ;;
        *)
            # do Nothing
            ;;
    esac
    #qc_debug "COMPREPLY >>${COMPREPLY[*]}<<"

    return 0
}
if [ "${BASH_VERSION:0:1}" -ge 4 ]; then
    complete  -F __qc_complete qc
else
    complete -o nospace -F __qc_complete qc
fi

# vim: ft=sh
#---------[ END OF FILE _quick_change_dir ]------------------------------------
