#
# FILE: _quick_change_dir
#
# ABSTRACT: Quick Change Directory
#
# Copy this file to $HOME/.quick_change_dir and add the following line to
# your .bashrc:
#  . $HOME/.quick_change_dir
#
# Portability:
# - KSH93: Should run unchanged. Needs testing.
# - KSH88: UNKNOWN
# - ZSH:   Some code have to be adjusted. Search for "ZSH"
#
#
# The base idea of quick change directory ("qc") is to create a index
# containing all directories in your HOME directory and to use the command 'qc'
# to quick change to a directory by searching for a matching name in that
# index. The index file is simple text file containing one directory per line.
#
# On sourcing this file two index files are created:
#
# 1) $HOME/.qc/home.index
# This contains all directories in your $HOME excluding hidden dirs.
# The file can be manually updated using 'qc -u'.
# -----------------------------------------------------------------------------
# I update this file automatically via a crontab job:
#     */10 * * * * ${HOME}/bin/qcBuildIdx.sh >/dev/null
# See "Create your own qcBuildIdx.sh" below.
# -----------------------------------------------------------------------------
#
# 2) $HOME/.qc/index.dstore
# This index file is to be managed manually by the command 'dstore' (provided
# by this file). This files contains 'normal' lines  that are just a directory
# name and 'labeled' lines, where the directory is prefixed by a label. A
# labeled entry looks like this:
#     :label /directory/path
# With dstore you can add and remove directories to/from ~/.qc/index.dstore,
# list the content or open it in a editor.
# More details in section "Managing $HOME/.qc/index.dstore" below.
#
# Extended index
# --------------
# By default qc searches the files ~/.qc/*.index and ~/.qc/index.dstore for
# matching directories.
# Additionally files with a name ~/.qc/*.index.ext can be created. This files
# are called "extended index" and are only searched if qc is called with the
# parameter '-e'.
#
# -----------------------------------------------------------------------------
# Why?
# Well, most of the time I work "not-hidden" directories, only very very seldom
# I need to change to a hidden directory or its sub directory. So my home.index
# only contains "visible" directories and I keep the hidden directories in a 
# separate home.hidden.index.ext. If I need to change to a potential hidden
# directory I use qc -e ...
# -----------------------------------------------------------------------------
#
# Create your own qcBuildIdx.sh
# -----------------------------
# If you didn't get the script qcBuildIdx.sh with this file, it can be
# extracted from this file. Just search for the function
# "__qc_internalUpdateIndex" below and copy the content to a file called
# "qcBuildIdx.sh". Add the line "#!/bin/bash" (or ksh or zsh) as the first line
# and then put that file somewhere on your path.
# This is only needed if you want to call that script via cronjob as described
# above.
#
#
# Changing directories
# ====================
#
# The command 'qc' searches the index files and quickly changes directories.
#
# qc supports three ways to search for the directory:
#
# 1) Search by (parts of the) directory name
#
# Example: qc Pro
#    This command searches for a directory with a name matched by
#        ^.*/Pro[^/]*$
#    It would match somthing like
#        ~/Documents/Customer/Project
#        ~/Documents/Customer/YoYo/Protocols
#        ~/Documents/private/Profile
#
#    If only one name matches, the directory is changed to that dir.
#    If multiple entries matches, a list of possible target directories is
#    displayed. Choose one by number and the directory is changed.
#
# Example: qc Project/Ser
#    This command searches for a directory with a name matched by
#        ^.*/Project/Ser[^/]*$
#    It would match somthing like
#        ~/Documents/Customer/Project/Server
#        ~/Documents/Customer/Project/Serial
#
# Example: qc Project/Ser/
#    This command searches for a directory with a name matched by
#        ^.*/Project/Ser$
#    (So no wildcards at the end)
#
# Example: qc Documents//Cust
#    This command searches for a directory with a name matched by
#        ^.*/Documents/\(.*/\)*Cust[^/]*$
#    It would match somthing like
#        .../Documents/Customer or
#        .../Documents/Test/Customer or
#        .../Documents/Stuff/YoYo/Test/Customer
#
# 2) Search with multiple parameters
#
# Example: qc Project Ser
#    This command searches for a directory with a name matched by
#        ^.*/Project[^/]*/Ser[^/]*$
#    It would match somthing like
#        ~/Documents/Customer/Project/Server
#        ~/Documents/Customer/Project/Serial
#        ~/Documents/Customer/Project-Test/Server
#
#    Note: Trailing '/' prevents appending wildcards.
#    So:
#        qc Project/ Ser
#    is equivalent to
#        qc Project/Ser
#
# 3) Search by label
#    (see section "Managing $HOME/.qc/index.dstore" below)
#
#    Example: qc :apachelog
#    This searches for a entry that is labeled with ":apachelog". It finds the
#    following entry:
#
#        :apachelog /opt/IBM/HTTPServer/logs
#
#    Note: Labels are case-insensitive!
#
# Multiple matches:
# -----------------
#
# If multiple directories matches, a selection list is displayed:
#
#     $ qc Admin
#     1) /home/john/Documents/Customer/YoYo/Admin
#     2) /home/john/Documents/Customer/ACME/Project1/Admin
#     3) /home/john/Documents/Customer/ACME/Project2/Admin
#     4) /home/john/Documents/shared/Servers/Admin
#     #?
#
# Select the directory to change to by number. Enter 'q' to abort.
#
# Details on Expression
# ---------------------
#
# 1) The expression is case-sensitive. Use qc -i ... to switch to
#    case-insensitive matching.
# 2) The character '+' is equivalent to '*'. The '+' doesn't need escaping on
#    the command line.
# 3) Every word, that does not end with a '/' gets a '*' appended before it is
#    joined with the next word with a '/'.
#    So:
#       Hallo World  -> Hallo*/World*
#       Hallo/ World -> Hallo/World*
#       Hallo/World  -> Hallo/World*
#       Hallo/World/ -> Hallo/World
# 4) The single wildcard '*' matches all but a '/'.
# 5) The wildcard combination '**/' matches zero or more directory names.
#    So:
#       Hello/**/World  matches Hello/World, Hello/my/World,
#           Hello/small/blue/World ...
# 6) A double slash ('//') is equivalent to '/**/'.
# 7) A double asteriks _not_ followd by '/' matches zero or more characters
#    (including '/')
#
# Note: More than two consecutive '*' are handled as '**'. The same is true
#       for '/'. So:
#         '***'    is equivalent to '**'
#         '*****'  is equivalent to '**'
#         '/////'  is equivalent to '//'
#
# Regex:
#
# **/    \(.*/\)*
# ++/    \(.*/\)*
# **     .*
# ++     .*
# *      [^\/]*
# +      [^\/]*
# //     \(.*/\)*
#
#
#
# Command line completion
# -----------------------
#
# Bash command line completion is supported for 'qc'. Just use <TAB> as you
# would do for the cd commands.
#
# Multiple ways
# -------------
#
# Assume you have a directory
#
#    ~/Documents/Customer/YoYo/MyProject/Admin
#
# Examples to change to that directory:
#
#    qc C Y M A
#    qc MyPr Adm
#    qc MyProject/Ad
#    qc Customer//Admin    # "Admin" somewhere below "Customer"
#    qc YoYo/+/Admin       # '+' matches on subdirs
#    qc Customer/++/Admin  # '++' matches multiple subdirs
#    qc YoYo + Admin
#    qc Cust ++ Admin
#
# Other qc option:
# ----------------
#
#    -i  Search is case-insensitive (and slower). Only when searching by name.
#    -u  Update the index file ~/.qc/home.index. If available, the external
#        script qcBuildIdx.sh is used.
#    -l  List labeled directories.
#    -S  Print statistics of index files
#
#    Note:
#    * calling 'qc' without parameter acts like calling 'cd' without parameter
#    * calling 'qc -' acts like calling 'cd -'
#
#
# Managing $HOME/.qc/index.dstore
# ===============================
#
# The file $HOME/.qc/index.dstore is managed with the command 'dstore':
#
# dstore
#     Adds the current dir to ~/.qc/index.dstore
#
# dstore dirname
#     Adds the named dir to ~/.qc/index.dstore
#
# dstore -d
#     Removes the current dir from ~/.qc/index.dstore
#
# dstore -d dirname
#     Removes the named dir from ~/.qc/index.dstore
#
# dstore :lbl
#     Adds the current dir with the label ':lbl' to ~/.qc/index.dstore
#     Note: A label must always start with a ':'.
#
# dstore :lbl dirname
#     Adds the named dir with the label ':lbl' to ~/.qc/index.dstore
#
# dstore -d :lbl
#     Removes the entry labeled with ':lbl' from ~/.qc/index.dstore
#
# dstore -l
#     Lists content of ~/.qc/index.dstore
#
# dstore -e
#     Opens ~/.qc/index.dstore in a editor (default vi)
#
# dstore -c
#     Cleans up ~/.qc/index.dstore by removing none-existing or duplicate
#     entries or entries already contained in another index file. It also
#     warns about duplicate labels.
#
# On every add or delete operation a warning is printed for none existent
# entries. Use 'dstore -c' to clean up.
#
#
# AUTHOR: Ralf Schandl
#

# Directory for qc index files
QC_DIR=$HOME/.qc

# Manual index file storing directory names and bookmarked directories. This
# file is managed using the command 'dstore'.
QC_DSTORE_INDEX=$QC_DIR/index.dstore

#function qc_debug
#{
#    echo "$*" >> $HOME/qc-debug.log
#    echo >&2 "$@"
#}

# Create regex from qc argument
# Used from qc and completion
# $*: The pattern to create a regex
function __qc_make_regex
{
    #qc_debug "Pattern 0 >>$(printf "'%s' " "$@")<<"

    printf "%s\t" "$@" | awk -F$'\t' '{
    sub(/^\/\/*/, "", $1);
    for (i=1; i<NF; i++) {
        x=$i;
        sub(/^\//, "", x);
        gsub(/\*/, "+", x);
        if (x ~ /\+$/ ) {
            r = r x "/";
        }
        else if (x ~ /[^\/]$/ ) {
            r = r x "+/";
        }
        else {
            r = r x;
        }
    }
    gsub(/\./, "\\.", r);
    sub(/\/\/*$/, "$", r);
    sub(/^(\+\+*\/)+/, "", r);
    gsub(/\+\+\+*\//, "\\(.*/\\)*", r);
    gsub(/\+\+\+*/, ".*", r);
    gsub(/\+/, "[^/]*", r);
    gsub(/\/\/\/*/, "/\\(.*/\\)*", r);
    gsub(/\?/, "[^/]", r);
    sub(/^~\//, ENVIRON["HOME"] "/", r);
    sub(/^\.\//, ENVIRON["PWD"] "/", r);
    sub(/^\/\/*/, "", r);
    print r;
    }'
}

# Select directories found in ~/.qc/*.index.
# $1: grep options (ignored for search by label)
# $2: Search extended indexes? ("true" or "")
# $3-: text to search for. With leading ':' triggers search by label.
function __qc_select
{
    typeset grepOpt="$1"
    shift
    typeset searchExtIdx="$1"
    shift

    if [ $searchExtIdx ]; then
        if ls $QC_DIR/*.index.ext >/dev/null 2>&1; then
            extIdx="$QC_DIR/*.index.ext"
        fi
    fi

    typeset IFS=$'\n'
    typeset NO_IDX_MSG="qc: No index file found! Use 'qc -u' or 'dstore' to create it."
    typeset NO_DSTORE_IDX_MSG="qc: Dstore index file not found! Use 'dstore' to create it."
    typeset dl
    case $1 in
        :*)
            pattern=$1
            [ $# -gt 1 ] && echo >&2 "WARNING: Extra arguments ignored"
            # grep: -h: Suppress the prefixing of file names on output.
            dl=( $( (grep -h -i -- "^$pattern[^ ]* " $QC_DSTORE_INDEX||([ $? = 2 ] && echo >&2 "$NO_DSTORE_IDX_MSG")) | cut "-d " -f2- | sort | uniq) )
            ;;
        *)
            pattern=$(__qc_make_regex "$@")
            dl=( $( (grep --color=always -h $grepOpt -- "/$pattern" $QC_DIR/*.index $QC_DSTORE_INDEX $extIdx || ([ $? = 2 ] && echo >&2 "$NO_IDX_MSG"))|sed "s/^:[^ ]* //"|sort|uniq) )
            ;;
    esac

    typeset cnt=${#dl[*]}

    if [[ $cnt -eq 0 ]]; then
        echo >&2 "qc: $@: No matching directory found"
    elif [[ $cnt -eq 1 ]]; then
        # echo and remove color codes
        echo "${dl[@]}" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
    else
        # If selection list needs more than terminal hight lines
        # ask user, if he/she really want's to see it.
        typeset limit=$(($LINES -1))
        if [[ $cnt -gt $limit ]]; then

            echo >&2 -n "Display all $cnt possibilities? (y or n) "
            read -N1 yn
            # ZSH: read -k "yn?Display all $cnt possibilities? (y or n) "
            case $yn in
                y|Y) echo >&2
                    ;;
                *) echo >&2
                    return;;
            esac
        fi

        typeset COLUMNS=0
        # replace home directory with '~' for display and later re-add it on
        # choosen dir.
        dl=( "${dl[@]/#$HOME/\~}" )
        # ZSH: dl=( "${dl[@]/#$HOME/~}" )
        # ZSH: On ZSH the following select only display subset (term lines)
        export LINES=0
        select dir in "${dl[@]}" ; do
            # replace ~ with $HOME and remove color codes
            echo "${dir/#\~/$HOME}" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
            break
        done
    fi
}

# Quick change directory
function qc
{
    # The command used for changing directories
    if [ $BASH_VERSION ]; then
        typeset CD_CMD="builtin cd"
    else
        typeset CD_CMD="cd"
    fi

    # no argument - cd to home
    if [[ $# -eq 0 ]]; then
        $CD_CMD
        return $?
    elif [[ "$1" = "-" ]]; then
        $CD_CMD -
        return $?
    fi

    typeset grepOpt=""
    typeset searchExtIdx=""
    typeset OPTIND
    typeset o

    while getopts ":ieuSl" o "$@"; do
        case $o in
            i) grepOpt="-i"
                ;;
            e) searchExtIdx="true"
                ;;
            u)
                shift $((OPTIND-1))
                __qc_updateIndex "$@"
                return 0
                ;;
            S)
                typeset fn
                for fn in $QC_DIR/*.index $QC_DIR/*.index.ext; do
                    if [ -e "$fn" ]; then
                        echo "$fn"
                        echo "   Last Upd: $(stat -c "%y" $fn)"
                        printf "   Entries:  %'d (%'d bytes)\n" $(cat "$fn" | wc -lc)
                    fi
                done
                if [ -e "$QC_DSTORE_INDEX" ]; then
                    echo "$QC_DSTORE_INDEX"
                    echo "   Last Upd: $(stat -c "%y" $QC_DSTORE_INDEX)"
                    printf "   Entries:  %'d (%'d bytes)\n" $(cat "$QC_DSTORE_INDEX" | wc -lc)
                    echo "   Labeled entries:  $(grep "^:" $QC_DSTORE_INDEX|wc -l| cut "-d " -f1)"
                fi
                return 0
                ;;
            l)
                grep '^:[^ ]* ' $QC_DSTORE_INDEX
                return 0
                ;;
            *)
                [ "${!OPTIND}" != "--help" ] && echo >&2 "can't parse: ${!OPTIND}" && echo >&2 ""
                echo >&2 "Quick Change -- index based directory changer"
                echo >&2 ""
                echo >&2 "Usage:"
                echo >&2 "  qc [-ie] <dir>"
                echo >&2 "      Search for dir in index and cd to it."
                echo >&2 "      -i  Search case-insensitive (slower)."
                echo >&2 "      -e  Also search extended index."
                echo >&2 "  qc :name"
                echo >&2 "      Search for dir labeled with ':name' in index and cd to it."
                echo >&2 "      Use the command 'dstore' to manage labeled directories."
                echo >&2 "  qc -u [dir...]"
                echo >&2 "      Updates index. If dirs are given only that directories are updated,"
                echo >&2 "      This uses the external command '~/.qc/qc-process-idx-list.sh', if it"
                echo >&2 "      is available. Else the internal update is used."
                echo >&2 "  qc -l"
                echo >&2 "      List labeled dirs."
                echo >&2 "  qc -S"
                echo >&2 "      Print statistics of index."
                echo >&2 "  qc -"
                echo >&2 "      Act like 'cd -'."
                echo >&2 ""
                echo >&2 "Note: qc automatically adds wildcards"
                echo >&2 "  'qc Documents/Adm' searches for '**/Documents/Adm*'"
                echo >&2 "  'qc Doc Adm' searches for '**/Doc*/Adm*'"
                echo >&2 ""
                echo >&2 "See also: dstore --help"
                echo >&2 ""
                return 1
                ;;
        esac
    done

    shift $((OPTIND-1))

    #qc_debug "ignorecase:   $ignorecase"
    #qc_debug "Args:         " $(printf '"%s" ' "$@")

    case $1 in
        ?*)
            typeset tgt=$(__qc_select "$grepOpt" "$searchExtIdx" "$@")
            if [[ -n "$tgt" ]]; then
                $CD_CMD "$tgt"
            else
                return 1
            fi
            ;;
    esac

}

# Update/create the index.
function __qc_updateIndex
{
    if [ -e $QC_DIR/qc-process-idx-list.sh ]; then
        echo "Updating index ..."
        typeset ARGS
        ARGS=()
        for d in "$@"; do
            d="$(readlink -f "$d")"
            ARGS+=( "-i" "$d")
        done
        
        $QC_DIR/qc-process-idx-list.sh "${ARGS[@]}"
    else
        echo "Updating index (internal update)..."
        __qc_internalUpdateIndex "$@"
    fi
}

function __qc_internalUpdateIndex
{
    # Root directory of the index
    typeset ROOT="$HOME"

    # Name of the index
    typeset IDX_NAME="home"

    # Array of directories to ignore
    typeset -a IGNORE_DIRS
    IGNORE_DIRS=( '.*' CVS )

    [ ! $QC_DIR ] && QC_DIR="$HOME/.qc"
    [ ! -d "$QC_DIR" ] && mkdir $QC_DIR

    typeset INDEX_FILE=$QC_DIR/$IDX_NAME.index

    typeset NEW_INDEX=$(mktemp ${INDEX_FILE}.XXXX)

    typeset -a ignDirs
    for ign in "${IGNORE_DIRS[@]}"; do
        if [ ${#ignDirs[@]} -gt 0 ]; then
            ignDirs+=(-o)
        fi
        if [[ "$ign" =~ ^/.*$ ]]; then
            ignDirs+=(-wholename)
        elif [[ "$ign" =~ ^\./.*$ ]]; then
            ignDirs+=(-wholename)
            ign="${ROOT}${ign:1}"
        elif [[ "$ign" =~ ^.*/.*$ ]]; then
            ignDirs+=(-wholename)
            ign="*$ign"
        else
            ignDirs+=(-name)
        fi
        ignDirs+=( "$ign" )
    done

    typeset -a searchDirs
    if [ $# -ne 0 ] && [ -e $INDEX_FILE ]; then
        for d in "$@"; do
            d="$(readlink -f "$d")"
            if [ -d "$d" ]; then
                searchDirs=( "${searchDirs[@]}" "$d" )
            else
                echo >&2 "WARN: $d does not exist"
            fi
        done
        if [ ${#searchDirs[@]} -eq 0 ]; then
            echo >&2 "No dir found: [ $@ ]"
            return 1
        fi

        re=$(printf "%s|" "${searchDirs[@]}")
        re=${re:0:-1}
        egrep -v "^($re)(/|$)" $INDEX_FILE > $NEW_INDEX
    else
        searchDirs=( "$ROOT" )
    fi

    # find all directories excluding hidden dirs and those configured above
    if [ ${#ignDirs[@]} -gt 0 ]; then
        find "${searchDirs[@]}" -xdev -type d \( "${ignDirs[@]}" \) -prune -o -xtype d -print >> $NEW_INDEX
    else
        find "${searchDirs[@]}" -xdev -xtype d -print >> $NEW_INDEX
    fi

    # replace .qc/index with new content
    mv -f $NEW_INDEX $INDEX_FILE

    echo "Stored $(wc -l < $INDEX_FILE) directory names."
}

if [ ! -e $QC_DIR/home.index ]; then
    echo "QuickChangeDirectory: No index files found .. creating ..."
    __qc_updateIndex
fi
if [ ! -e $QC_DSTORE_INDEX ]; then
    touch $QC_DSTORE_INDEX
fi


# cleanup ~/.qc/index.dstore
function __dstore_clean
{
    # if action is 'warn' just warn about none-existing dirs
    typeset action=$1
    # delete duplicates
    LC_ALL=C sort $QC_DSTORE_INDEX | uniq > $QC_DSTORE_INDEX.tmp
    mv -f $QC_DSTORE_INDEX.tmp $QC_DSTORE_INDEX

    # get other index files
    typeset -a otherIdx
    for fn in $QC_DIR/*.index; do
        if [[ $fn != $QC_DSTORE_INDEX ]]; then
            otherIdx+=($fn)
        fi
    done
    if [ ${#otherIdx[*]} -eq 0 ]; then
        otherIdx+=( /dev/null )
    fi

    typeset IFS=$'\n'
    typeset labels=""
    > $QC_DSTORE_INDEX.tmp
    while read d; do
        case $d in
            :*)
                # remove non-existing dirs and warn on duplicate labels
                lbl=$(echo "$d" | cut "-d " -f1)
                dir=$(echo "$d" | cut "-d " -f2-)

                if [ -d "$dir" ]; then
                    echo "$d" >> $QC_DSTORE_INDEX.tmp
                    if echo "$labels" | grep -i  " $lbl " >/dev/null 2>&1; then
                        echo >&2 "Warning: Duplicate label: '$lbl'"
                    fi
                    labels="$labels $lbl "
                else
                    if [ "$action" = "warn" ]; then
                        echo "$d" >> $QC_DSTORE_INDEX.tmp
                        echo >&2 "WARNING $d: Does not exist (anymore). Use 'dstore -c' to clean up."
                    else
                        echo >&2 "Removed $d: Does not exist (anymore)."
                    fi
                fi
                ;;
            ?*)
                # ignore dirs already in another index file
                if grep "^${d}$" "${otherIdx[@]}" >/dev/null 2>&1; then
                    echo >&2 "Removed $d: Already in "$(grep -l "^${d}$" "${otherIdx[@]}")
                    continue
                fi
                # remove non-existing dirs
                if [ -d "$d" ]; then
                    echo "$d" >> $QC_DSTORE_INDEX.tmp
                else
                    if [ "$action" = "warn" ]; then
                        echo "$d" >> $QC_DSTORE_INDEX.tmp
                        echo >&2 "WARNING $d: Does not exist (anymore). Use 'dstore -c' to clean up."
                    else
                        echo >&2 "Removed $d: Does not exist (anymore)."
                    fi
                fi
                ;;
        esac
    done < $QC_DSTORE_INDEX
    mv -f $QC_DSTORE_INDEX.tmp $QC_DSTORE_INDEX
}

function __qc_fqname
{
    if [ -d "$1" ]; then
        echo "$(builtin cd -- "$1" && pwd)"
        [ $? -ne 0 ] && return 1
    else
        echo "$(builtin cd "$(dirname -- "$1")" && echo -n "$(pwd)" && echo "/$(basename -- "$1")")"
    fi
}

#
# Command to manage the manual dir index
#
function dstore
{
    # create ~/.qc/index.dstore if it does not exist.
    [ ! -d "$QC_DIR" ] && mkdir $QC_DIR
    [ ! -e "$QC_DSTORE_INDEX" ] && touch $QC_DSTORE_INDEX

    typeset delete
    typeset OPTIND

    while getopts ":elcd" o "$@"; do
        case $o in
            e)
                ${EDITOR:-vi} $QC_DSTORE_INDEX
                __dstore_clean warn
                return
                ;;
            l)
                cat $QC_DSTORE_INDEX
                return
                ;;
            c) __dstore_clean
                return
                ;;
            d) delete=true
                ;;
            *)
                [ "${!OPTIND}" != "--help" ] && echo >&2 "can't parse: ${!OPTIND}" && echo >&2 ""
                echo >&2 "Manually manage content of $QC_DSTORE_INDEX for usage with 'qc'."
                echo >&2 ""
                echo >&2 "Usage:"
                echo >&2 "  dstore"
                echo >&2 "      store current directory"
                echo >&2 "  dstore dirname"
                echo >&2 "      store given directory"
                echo >&2 "  dstore -d"
                echo >&2 "      remove current directory from index"
                echo >&2 "  dstore -d dirname"
                echo >&2 "      remove given directory from index"
                echo >&2 "  dstore :lbl"
                echo >&2 "      store current directory with label ':lbl'"
                echo >&2 "  dstore :lbl dirname"
                echo >&2 "      store given directory with label ':lbl'"
                echo >&2 "  dstore -d :lbl"
                echo >&2 "      remove directory labeled with ':lbl' from index"
                echo >&2 "  dstore [-e | -l | -c]"
                echo >&2 "      '-e'  edit directory index (using ${EDITOR:-vi})"
                echo >&2 "      '-l'  list directory index"
                echo >&2 "      '-c'  clean up duplicate/none-existing entries"
                echo >&2 ""
                echo >&2 "See also: qc --help"
                echo >&2 ""
                return
                ;;
        esac
    done

    shift $((OPTIND-1))

    if [ $# -eq 0 ]; then
        set -- '.'
    fi

    /bin/cp -f $QC_DSTORE_INDEX $QC_DSTORE_INDEX.org
    while [ $# -gt 0 ]; do
        case $1 in
            :*)
                typeset lbl=$1
                shift
                if ! echo "$lbl" | grep "^[^[:space:]]*$" >/dev/null 2>&1; then
                    echo >&2 "Invalid label '$lbl'. Must not contain whitespaces."
                    return 1
                fi
                grep -v "^$lbl " $QC_DSTORE_INDEX > $QC_DSTORE_INDEX.tmp
                mv $QC_DSTORE_INDEX.tmp $QC_DSTORE_INDEX
                if [ "$delete" != "true" ]; then
                    typeset dir
                    if [ $# -lt 1 ]; then
                        dir=$(__qc_fqname ".")
                    else
                        dir=$(__qc_fqname "$1")
                        shift
                    fi
                    if [ -d "$dir" ]; then
                        echo "$lbl $dir" >> $QC_DSTORE_INDEX
                    else
                        echo >&2 "Error: Not a directory: $dir"
                    fi
                fi
                ;;
            ?*)
                dir=$(__qc_fqname "$1")
                shift
                if [ "$delete" = "true" ]; then
                    grep -v "^${dir}$" $QC_DSTORE_INDEX > $QC_DSTORE_INDEX.tmp
                    mv $QC_DSTORE_INDEX.tmp $QC_DSTORE_INDEX
                else
                    if [ -d "$dir" ]; then
                        echo $dir >> $QC_DSTORE_INDEX
                    else
                        echo >&2 "Error: Not a directory: $dir"
                    fi
                fi
                ;;
        esac
    done
    diff $QC_DSTORE_INDEX.org $QC_DSTORE_INDEX | grep -- "^[<>]" | sed "s/^</Removed:/;s/^>/Added:  /"
    rm $QC_DSTORE_INDEX.org
    __dstore_clean warn
}

if [ -z "$BASH_VERSION" ]; then
    return
fi
#
# The following is bash-only
#

# qc completion function
function __qc_complete
{
    #qc_debug "_qc_complet ============================"
    typeset cur prev opts
    COMPREPLY=()
    if [ ${BASH_VERSION:0:1} -ge 4 ]; then
        _get_comp_words_by_ref -n : cur
    else
        cur=$(echo ${COMP_LINE:0:$COMP_POINT}|sed "s/^.* //")
    fi
    prev="${COMP_WORDS[*]}"
    #qc_debug "cur >>$cur<<"
    #qc_debug "prev >>$prev<<"
    #qc_debug "CL >>$COMP_LINE<<"

    typeset ic
    typeset sedIC
    if echo "$prev" | grep " -[^ ]*i" >/dev/null 2>&1 ; then
        ic='-i'
        sedIC="i"
    fi
    typeset extIdx
    if echo "$prev" | grep " -[^ ]*e" >/dev/null 2>&1 ; then
        if ls $QC_DIR/*.index.ext >/dev/null 2>&1; then
            extIdx="$QC_DIR/*.index.ext"
        fi
    fi
    #qc_debug "CW >>${COMP_WORDS[@]}<<"

    typeset -a parts=( "${COMP_WORDS[@]}" )
    unset parts[0]
    parts=( "${parts[@]}" )
    #qc_debug "XX ${parts[0]}"
    while [[ ${parts[0]} == -* ]]; do
        #qc_debug "unsetting ${parts[0]}"
        unset parts[0]
        parts=( "${parts[@]}" )
    done
    #qc_debug "parts >>${parts[@]}<<"

    case "$cur" in
        \~ | \~/*)
            _filedir -d;
            return 0;
            ;;
        . | .. | ../* | ./*)
            _filedir -d;
            return 0;
            ;;
        ':'*)
            #qc_debug "LABEL"
            opts=$(grep "^${cur}[^ ]* " $QC_DSTORE_INDEX | cut "-d " -f1 | sort | uniq)
            #qc_debug "$opts"
            COMPREPLY=( $(compgen "-S " -W "${opts[*]}" -- "$cur" ))
            typeset i
            for ((i=0; i < ${#COMPREPLY[@]}; i++)); do
                COMPREPLY[$i]=$(printf "%q" "${COMPREPLY[$i]:1}")
                if [ ${BASH_VERSION:0:1} -lt 4 ]; then
                    COMPREPLY[$i]="${COMPREPLY[$i]} "
                fi
            done
            #qc_debug "COMPREPLY >>${COMPREPLY[*]}<<"
            ;;
        ?*)
            cur=$(eval echo "$cur" 2>/dev/null || eval echo "$cur'" 2>/dev/null || eval echo "$cur\"" 2>/dev/null || "")
            #qc_debug "cur >>$cur<<"
            cur=$(echo "$cur" | sed "s%^/%%")   # remove leading '/'
            # curRE: Regular expression to find dir in index
            typeset curRE=$(__qc_make_regex "${parts[@]}")
            typeset curRE=$(echo "$curRE" | sed "s%\([^*]\)\$$%\1/[^/]*$%")
            # cleanRE: RE to delete unneeded part from result
            typeset cleanRE=$(echo "$curRE" | sed "s%\[^/\]\*.$%%")
            #qc_debug "curRE >>$curRE<<"
            #qc_debug "cleanRE >>$cleanRE<<"
            typeset IFS=$'\n'
            opts=($(grep --no-filename $ic -o -- "/$curRE" $QC_DIR/*.index $extIdx | sort | uniq  | sed "s|^.*/${cleanRE}|/${cur}|$sedIC" | cut -c2-))
            #qc_debug "OPTS >>${opts[*]}<<"
            COMPREPLY=( $(compgen -o nospace -S/ -W "${opts[*]}" -- "$cur" ))
            #COMPREPLY=( "${opts[@]}")
            if [ ${BASH_VERSION:0:1} -ge 4 ]; then
                compopt -o nospace
            fi
            #qc_debug "COMPREPLY >>${COMPREPLY[*]}<<"
            for ((i=0; i < ${#COMPREPLY[@]}; i++)); do
                COMPREPLY[$i]=$(printf "%q" "${COMPREPLY[$i]}")
            done
            ;;
        *)
            # do Nothing
            ;;
    esac
    #qc_debug "COMPREPLY >>${COMPREPLY[*]}<<"

    return 0
}
if [ ${BASH_VERSION:0:1} -ge 4 ]; then
    complete  -F __qc_complete qc
else
    complete -o nospace -F __qc_complete qc
fi

# vim: ft=sh
#---------[ END OF FILE _quick_change_dir ]------------------------------------
